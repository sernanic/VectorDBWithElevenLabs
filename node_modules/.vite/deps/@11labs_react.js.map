{
  "version": 3,
  "sources": ["../../@11labs/client/src/utils/audio.ts", "../../@11labs/client/src/utils/rawAudioProcessor.ts", "../../@11labs/client/src/utils/input.ts", "../../@11labs/client/src/utils/audioConcatProcessor.ts", "../../@11labs/client/src/utils/output.ts", "../../@11labs/client/src/utils/events.ts", "../../@11labs/client/src/utils/connection.ts", "../../@11labs/client/src/index.ts", "../../@11labs/react/src/index.ts"],
  "sourcesContent": ["export function arrayBufferToBase64(b: ArrayBufferLike) {\n  const buffer = new Uint8Array(b);\n  // @ts-ignore\n  const base64Data = window.btoa(String.fromCharCode(...buffer));\n  return base64Data;\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n}\n", "const blob = new Blob(\n  [\n    `\n      const TARGET_SAMPLE_RATE = 16000;\n      class RawAudioProcessor extends AudioWorkletProcessor {\n        constructor() {\n          super();\n          this.buffer = []; // Initialize an empty buffer\n          this.bufferSize = TARGET_SAMPLE_RATE / 4; // Define the threshold for buffer size to be ~0.25s\n\n          if (globalThis.LibSampleRate && sampleRate !== TARGET_SAMPLE_RATE) {\n            globalThis.LibSampleRate.create(1, sampleRate, TARGET_SAMPLE_RATE).then(resampler => {\n              this.resampler = resampler;\n            });\n          }\n        }\n        process(inputs, outputs) {\n          const input = inputs[0]; // Get the first input node\n          if (input.length > 0) {\n            let channelData = input[0]; // Get the first channel's data\n\n            // Resample the audio if necessary\n            if (this.resampler) {\n              channelData = this.resampler.full(channelData);\n            }\n\n            // Add channel data to the buffer\n            this.buffer.push(...channelData);\n            // Get max volume \n            let sum = 0.0;\n            for (let i = 0; i < channelData.length; i++) {\n              sum += channelData[i] * channelData[i];\n            }\n            const maxVolume = Math.sqrt(sum / channelData.length);\n            // Check if buffer size has reached or exceeded the threshold\n            if (this.buffer.length >= this.bufferSize) {\n              const float32Array = new Float32Array(this.buffer)\n              let pcm16Array = new Int16Array(float32Array.length);\n\n              // Iterate through the Float32Array and convert each sample to PCM16\n              for (let i = 0; i < float32Array.length; i++) {\n                // Clamp the value to the range [-1, 1]\n                let sample = Math.max(-1, Math.min(1, float32Array[i]));\n            \n                // Scale the sample to the range [-32768, 32767] and store it in the Int16Array\n                pcm16Array[i] = sample < 0 ? sample * 32768 : sample * 32767;\n              }\n            \n              // Send the buffered data to the main script\n              this.port.postMessage([pcm16Array, maxVolume]);\n            \n              // Clear the buffer after sending\n              this.buffer = [];\n            }\n          }\n          return true; // Continue processing\n        }\n      }\n      registerProcessor(\"raw-audio-processor\", RawAudioProcessor);\n  `,\n  ],\n  { type: \"application/javascript\" }\n);\n\nexport const rawAudioProcessor = URL.createObjectURL(blob);\n", "import { rawAudioProcessor } from \"./rawAudioProcessor\";\n\nconst LIBSAMPLERATE_JS =\n  \"https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js\";\n\nexport class Input {\n  public static async create(sampleRate: number): Promise<Input> {\n    let context: AudioContext | null = null;\n    let inputStream: MediaStream | null = null;\n\n    try {\n      const supportsSampleRateConstraint =\n        navigator.mediaDevices.getSupportedConstraints().sampleRate;\n\n      context = new window.AudioContext(\n        supportsSampleRateConstraint ? { sampleRate } : {}\n      );\n      const analyser = context.createAnalyser();\n      if (!supportsSampleRateConstraint) {\n        await context.audioWorklet.addModule(LIBSAMPLERATE_JS);\n      }\n      await context.audioWorklet.addModule(rawAudioProcessor);\n\n      inputStream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: { ideal: sampleRate },\n          echoCancellation: { ideal: true },\n          noiseSuppression: { ideal: true },\n        },\n      });\n\n      const source = context.createMediaStreamSource(inputStream);\n      const worklet = new AudioWorkletNode(context, \"raw-audio-processor\");\n\n      source.connect(analyser);\n      analyser.connect(worklet);\n\n      return new Input(context, analyser, worklet, inputStream);\n    } catch (error) {\n      inputStream?.getTracks().forEach(track => track.stop());\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly worklet: AudioWorkletNode,\n    public readonly inputStream: MediaStream\n  ) {}\n\n  public async close() {\n    this.inputStream.getTracks().forEach(track => track.stop());\n    await this.context.close();\n  }\n}\n", "const blob = new Blob(\n  [\n    `\n      class AudioConcatProcessor extends AudioWorkletProcessor {\n        constructor() {\n          super();\n          this.buffers = []; // Initialize an empty buffer\n          this.cursor = 0;\n          this.currentBuffer = null;\n          this.wasInterrupted = false;\n          this.finished = false;\n\n          this.port.onmessage = ({ data }) => {\n            switch (data.type) {\n              case \"buffer\":\n                this.wasInterrupted = false;\n                this.buffers.push(new Int16Array(data.buffer));\n                break;\n              case \"interrupt\":\n                this.wasInterrupted = true;\n                break;\n              case \"clearInterrupted\":\n                if (this.wasInterrupted) {\n                  this.wasInterrupted = false;\n                  this.buffers = [];\n                  this.currentBuffer = null;\n                }\n            }\n          };\n        }\n        process(_, outputs) {\n          let finished = false;\n          const output = outputs[0][0];\n          for (let i = 0; i < output.length; i++) {\n            if (!this.currentBuffer) {\n              if (this.buffers.length === 0) {\n                finished = true;\n                break;\n              }\n              this.currentBuffer = this.buffers.shift();\n              this.cursor = 0;\n            }\n\n            output[i] = this.currentBuffer[this.cursor] / 32768;\n            this.cursor++;\n\n            if (this.cursor >= this.currentBuffer.length) {\n              this.currentBuffer = null;\n            }\n          }\n\n          if (this.finished !== finished) {\n            this.finished = finished;\n            this.port.postMessage({ type: \"process\", finished });\n          }\n\n          return true; // Continue processing\n        }\n      }\n\n      registerProcessor(\"audio-concat-processor\", AudioConcatProcessor);\n    `,\n  ],\n  { type: \"application/javascript\" }\n);\n\nexport const audioConcatProcessor = URL.createObjectURL(blob);\n", "import { audioConcatProcessor } from \"./audioConcatProcessor\";\n\nexport class Output {\n  public static async create(sampleRate: number): Promise<Output> {\n    let context: AudioContext | null = null;\n    try {\n      context = new AudioContext({ sampleRate });\n      const analyser = context.createAnalyser();\n      const gain = context.createGain();\n      gain.connect(analyser);\n      analyser.connect(context.destination);\n      await context.audioWorklet.addModule(audioConcatProcessor);\n      const worklet = new AudioWorkletNode(context, \"audio-concat-processor\");\n      worklet.connect(gain);\n\n      return new Output(context, analyser, gain, worklet);\n    } catch (error) {\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly gain: GainNode,\n    public readonly worklet: AudioWorkletNode\n  ) {}\n\n  public async close() {\n    await this.context.close();\n  }\n}\n", "import { Language } from \"./connection\";\n\nexport type UserTranscriptionEvent = {\n  type: \"user_transcript\";\n  user_transcription_event: { user_transcript: string };\n};\nexport type AgentResponseEvent = {\n  type: \"agent_response\";\n  agent_response_event: { agent_response: string };\n};\nexport type AgentAudioEvent = {\n  type: \"audio\";\n  audio_event: {\n    audio_base_64: string;\n    event_id: number;\n  };\n};\nexport type InterruptionEvent = {\n  type: \"interruption\";\n  interruption_event: {\n    event_id: number;\n  };\n};\nexport type InternalTentativeAgentResponseEvent = {\n  type: \"internal_tentative_agent_response\";\n  tentative_agent_response_internal_event: {\n    tentative_agent_response: string;\n  };\n};\nexport type ConfigEvent = {\n  type: \"conversation_initiation_metadata\";\n  conversation_initiation_metadata_event: {\n    conversation_id: string;\n    agent_output_audio_format: string;\n  };\n};\nexport type PingEvent = {\n  type: \"ping\";\n  ping_event: {\n    event_id: number;\n    ping_ms?: number;\n  };\n};\nexport type ClientToolCallEvent = {\n  type: \"client_tool_call\";\n  client_tool_call: {\n    tool_name: string;\n    tool_call_id: string;\n    parameters: any;\n    expects_response: boolean;\n  };\n};\n\n// TODO correction missing\nexport type IncomingSocketEvent =\n  | UserTranscriptionEvent\n  | AgentResponseEvent\n  | AgentAudioEvent\n  | InterruptionEvent\n  | InternalTentativeAgentResponseEvent\n  | ConfigEvent\n  | PingEvent\n  | ClientToolCallEvent;\n\nexport type PongEvent = {\n  type: \"pong\";\n  event_id: number;\n};\nexport type UserAudioEvent = {\n  user_audio_chunk: string;\n};\nexport type ClientToolResultEvent = {\n  type: \"client_tool_result\";\n  tool_call_id: string;\n  result: any;\n  is_error: boolean;\n};\nexport type InitiationClientDataEvent = {\n  type: \"conversation_initiation_client_data\";\n  conversation_config_override?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      first_message?: string;\n      language?: Language;\n    };\n    tts?: {\n      voice_id?: string;\n    };\n  };\n  custom_llm_extra_body?: any;\n};\nexport type OutgoingSocketEvent =\n  | PongEvent\n  | UserAudioEvent\n  | InitiationClientDataEvent\n  | ClientToolResultEvent;\n\nexport function isValidSocketEvent(event: any): event is IncomingSocketEvent {\n  return !!event.type;\n}\n", "import {\n  InitiationClientDataEvent,\n  ConfigEvent,\n  isValidSocketEvent,\n  OutgoingSocketEvent,\n} from \"./events\";\n\nconst MAIN_PROTOCOL = \"convai\";\n\nexport type Language =\n  | \"en\"\n  | \"ja\"\n  | \"zh\"\n  | \"de\"\n  | \"hi\"\n  | \"fr\"\n  | \"ko\"\n  | \"pt\"\n  | \"it\"\n  | \"es\"\n  | \"id\"\n  | \"nl\"\n  | \"tr\"\n  | \"pl\"\n  | \"sv\"\n  | \"bg\"\n  | \"ro\"\n  | \"ar\"\n  | \"cs\"\n  | \"el\"\n  | \"fi\"\n  | \"ms\"\n  | \"da\"\n  | \"ta\"\n  | \"uk\"\n  | \"ru\"\n  | \"hu\"\n  | \"no\"\n  | \"vi\";\nexport type SessionConfig = {\n  origin?: string;\n  authorization?: string;\n  overrides?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      firstMessage?: string;\n      language?: Language;\n    };\n    tts?: {\n      voiceId?: string;\n    };\n  };\n  customLlmExtraBody?: any;\n} & (\n  | { signedUrl: string; agentId?: undefined }\n  | { agentId: string; signedUrl?: undefined }\n);\n\nconst WSS_API_ORIGIN = \"wss://api.elevenlabs.io\";\nconst WSS_API_PATHNAME = \"/v1/convai/conversation?agent_id=\";\n\nexport class Connection {\n  public static async create(config: SessionConfig): Promise<Connection> {\n    let socket: WebSocket | null = null;\n\n    try {\n      const origin = config.origin ?? WSS_API_ORIGIN;\n      const url = config.signedUrl\n        ? config.signedUrl\n        : origin + WSS_API_PATHNAME + config.agentId;\n\n      const protocols = [MAIN_PROTOCOL];\n      if (config.authorization) {\n        protocols.push(`bearer.${config.authorization}`);\n      }\n      socket = new WebSocket(url, protocols);\n      const conversationConfig = await new Promise<\n        ConfigEvent[\"conversation_initiation_metadata_event\"]\n      >((resolve, reject) => {\n        socket!.addEventListener(\n          \"open\",\n          () => {\n            const overridesEvent: InitiationClientDataEvent = {\n              type: \"conversation_initiation_client_data\",\n            };\n\n            if (config.overrides) {\n              overridesEvent.conversation_config_override = {\n                agent: {\n                  prompt: config.overrides.agent?.prompt,\n                  first_message: config.overrides.agent?.firstMessage,\n                  language: config.overrides.agent?.language,\n                },\n                tts: {\n                  voice_id: config.overrides.tts?.voiceId,\n                },\n              };\n            }\n\n            if (config.customLlmExtraBody) {\n              overridesEvent.custom_llm_extra_body = config.customLlmExtraBody;\n            }\n\n            socket?.send(JSON.stringify(overridesEvent));\n          },\n          { once: true }\n        );\n        socket!.addEventListener(\"error\", reject);\n        socket!.addEventListener(\"close\", reject);\n        socket!.addEventListener(\n          \"message\",\n          (event: MessageEvent) => {\n            const message = JSON.parse(event.data);\n\n            if (!isValidSocketEvent(message)) {\n              return;\n            }\n\n            if (message.type === \"conversation_initiation_metadata\") {\n              resolve(message.conversation_initiation_metadata_event);\n            } else {\n              console.warn(\n                \"First received message is not conversation metadata.\"\n              );\n            }\n          },\n          { once: true }\n        );\n      });\n\n      const conversationId = conversationConfig.conversation_id;\n      const sampleRate = parseInt(\n        conversationConfig.agent_output_audio_format.replace(\"pcm_\", \"\")\n      );\n\n      return new Connection(socket, conversationId, sampleRate);\n    } catch (error) {\n      socket?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly socket: WebSocket,\n    public readonly conversationId: string,\n    public readonly sampleRate: number\n  ) {}\n\n  public close() {\n    this.socket.close();\n  }\n\n  public sendMessage(message: OutgoingSocketEvent) {\n    this.socket.send(JSON.stringify(message));\n  }\n}\n", "import { arrayBufferToBase64, base64ToArrayBuffer } from \"./utils/audio\";\nimport { Input } from \"./utils/input\";\nimport { Output } from \"./utils/output\";\nimport { Connection, SessionConfig } from \"./utils/connection\";\nimport {\n  ClientToolCallEvent,\n  isValidSocketEvent,\n  PingEvent,\n} from \"./utils/events\";\n\nexport type { IncomingSocketEvent } from \"./utils/events\";\nexport type { SessionConfig } from \"./utils/connection\";\n\nexport type Role = \"user\" | \"ai\";\nexport type Mode = \"speaking\" | \"listening\";\nexport type Status =\n  | \"connecting\"\n  | \"connected\"\n  | \"disconnecting\"\n  | \"disconnected\";\nexport type Options = SessionConfig & Callbacks & ClientToolsConfig;\nexport type ClientToolsConfig = {\n  clientTools: Record<\n    string,\n    (\n      parameters: any\n    ) => Promise<string | number | void> | string | number | void\n  >;\n};\nexport type Callbacks = {\n  onConnect: (props: { conversationId: string }) => void;\n  // internal debug events, not to be used\n  onDebug: (props: any) => void;\n  onDisconnect: () => void;\n  onError: (message: string, context?: any) => void;\n  onMessage: (props: { message: string; source: Role }) => void;\n  onModeChange: (prop: { mode: Mode }) => void;\n  onStatusChange: (prop: { status: Status }) => void;\n  onUnhandledClientToolCall?: (\n    params: ClientToolCallEvent[\"client_tool_call\"]\n  ) => void;\n};\n\nconst DEFAULT_SAMPLE_RATE = 16000;\n\nconst defaultClientTools = { clientTools: {} };\nconst defaultCallbacks: Callbacks = {\n  onConnect: () => {},\n  onDebug: () => {},\n  onDisconnect: () => {},\n  onError: () => {},\n  onMessage: () => {},\n  onModeChange: () => {},\n  onStatusChange: () => {},\n};\n\nexport class Conversation {\n  public static async startSession(\n    options: SessionConfig & Partial<Callbacks> & Partial<ClientToolsConfig>\n  ): Promise<Conversation> {\n    const fullOptions: Options = {\n      ...defaultClientTools,\n      ...defaultCallbacks,\n      ...options,\n    };\n\n    fullOptions.onStatusChange({ status: \"connecting\" });\n\n    let input: Input | null = null;\n    let connection: Connection | null = null;\n    let output: Output | null = null;\n\n    try {\n      input = await Input.create(DEFAULT_SAMPLE_RATE);\n      connection = await Connection.create(options);\n      output = await Output.create(connection.sampleRate);\n\n      return new Conversation(fullOptions, connection, input, output);\n    } catch (error) {\n      fullOptions.onStatusChange({ status: \"disconnected\" });\n      connection?.close();\n      await input?.close();\n      await output?.close();\n      throw error;\n    }\n  }\n\n  private lastInterruptTimestamp: number = 0;\n  private mode: Mode = \"listening\";\n  private status: Status = \"connecting\";\n  private inputFrequencyData?: Uint8Array;\n  private outputFrequencyData?: Uint8Array;\n  private volume: number = 1;\n\n  private constructor(\n    private readonly options: Options,\n    private readonly connection: Connection,\n    public readonly input: Input,\n    public readonly output: Output\n  ) {\n    this.options.onConnect({ conversationId: connection.conversationId });\n\n    this.connection.socket.addEventListener(\"message\", event => {\n      this.onEvent(event);\n    });\n    this.connection.socket.addEventListener(\"error\", event => {\n      this.updateStatus(\"disconnected\");\n      this.onError(\"Socket error\", event);\n    });\n    this.connection.socket.addEventListener(\"close\", () => {\n      this.updateStatus(\"disconnected\");\n      this.options.onDisconnect();\n    });\n\n    this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n    this.output.worklet.port.onmessage = this.onOutputWorkletMessage;\n    this.updateStatus(\"connected\");\n  }\n\n  public endSession = async () => {\n    if (this.status !== \"connected\") return;\n    this.updateStatus(\"disconnecting\");\n\n    this.connection.close();\n    await this.input.close();\n    await this.output.close();\n\n    this.updateStatus(\"disconnected\");\n  };\n\n  private updateMode = (mode: Mode) => {\n    if (mode !== this.mode) {\n      this.mode = mode;\n      this.options.onModeChange({ mode });\n    }\n  };\n\n  private updateStatus = (status: Status) => {\n    if (status !== this.status) {\n      this.status = status;\n      this.options.onStatusChange({ status });\n    }\n  };\n\n  private onEvent = async (event: MessageEvent) => {\n    try {\n      const parsedEvent = JSON.parse(event.data);\n\n      if (!isValidSocketEvent(parsedEvent)) {\n        return;\n      }\n\n      switch (parsedEvent.type) {\n        case \"interruption\": {\n          if (parsedEvent.interruption_event) {\n            this.lastInterruptTimestamp =\n              parsedEvent.interruption_event.event_id;\n          }\n          this.fadeOutAudio();\n          break;\n        }\n\n        case \"agent_response\": {\n          this.options.onMessage({\n            source: \"ai\",\n            message: parsedEvent.agent_response_event.agent_response,\n          });\n          break;\n        }\n\n        case \"user_transcript\": {\n          this.options.onMessage({\n            source: \"user\",\n            message: parsedEvent.user_transcription_event.user_transcript,\n          });\n          break;\n        }\n\n        case \"internal_tentative_agent_response\": {\n          this.options.onDebug({\n            type: \"tentative_agent_response\",\n            response:\n              parsedEvent.tentative_agent_response_internal_event\n                .tentative_agent_response,\n          });\n          break;\n        }\n\n        case \"client_tool_call\": {\n          if (\n            this.options.clientTools.hasOwnProperty(\n              parsedEvent.client_tool_call.tool_name\n            )\n          ) {\n            try {\n              const result = await this.options.clientTools[\n                parsedEvent.client_tool_call.tool_name\n              ](parsedEvent.client_tool_call.parameters) ?? \"Client tool execution successful.\"; // default client-tool call response\n\n              this.connection.sendMessage({\n                type: \"client_tool_result\",\n                tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n                result: result,\n                is_error: false,\n              });\n            } catch (e) {\n              this.onError(\n                \"Client tool execution failed with following error: \" +\n                  (e as Error)?.message,\n                {\n                  clientToolName: parsedEvent.client_tool_call.tool_name,\n                }\n              );\n              this.connection.sendMessage({\n                type: \"client_tool_result\",\n                tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n                result: \"Client tool execution failed: \" + (e as Error)?.message,\n                is_error: true,\n              });\n            }\n\n            break;\n          }\n\n          if (this.options.onUnhandledClientToolCall) {\n            this.options.onUnhandledClientToolCall(\n              parsedEvent.client_tool_call\n            );\n\n            break;\n          }\n\n          this.onError(\n            `Client tool with name ${parsedEvent.client_tool_call.tool_name} is not defined on client`,\n            {\n              clientToolName: parsedEvent.client_tool_call.tool_name,\n            }\n          );\n          this.connection.sendMessage({\n            type: \"client_tool_result\",\n            tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n            result: `Client tool with name ${parsedEvent.client_tool_call.tool_name} is not defined on client`,\n            is_error: true,\n          });\n\n          break;\n        }\n\n        case \"audio\": {\n          if (\n            this.lastInterruptTimestamp <= parsedEvent.audio_event.event_id!\n          ) {\n            this.addAudioBase64Chunk(parsedEvent.audio_event.audio_base_64);\n            this.updateMode(\"speaking\");\n          }\n          break;\n        }\n\n        case \"ping\": {\n          this.connection.sendMessage({\n            type: \"pong\",\n            event_id: (parsedEvent as PingEvent).ping_event.event_id,\n          });\n          // parsedEvent.ping_event.ping_ms can be used on client side, for example\n          // to warn if ping is too high that experience might be degraded.\n          break;\n        }\n\n        // unhandled events are expected to be internal events\n        default: {\n          this.options.onDebug(parsedEvent);\n          break;\n        }\n      }\n    } catch {\n      this.onError(\"Failed to parse event data\", { event });\n      return;\n    }\n  };\n\n  private onInputWorkletMessage = (event: MessageEvent): void => {\n    const rawAudioPcmData = event.data[0];\n    const maxVolume = event.data[1];\n\n    // check if the sound was loud enough, so we don't send unnecessary chunks\n    // then forward audio to websocket\n    //if (maxVolume > 0.001) {\n    if (this.status === \"connected\") {\n      this.connection.sendMessage({\n        user_audio_chunk: arrayBufferToBase64(rawAudioPcmData.buffer),\n        //sample_rate: this.inputAudioContext?.inputSampleRate || this.inputSampleRate,\n      });\n    }\n    //}\n  };\n\n  private onOutputWorkletMessage = ({ data }: MessageEvent): void => {\n    if (data.type === \"process\") {\n      this.updateMode(data.finished ? \"listening\" : \"speaking\");\n    }\n  };\n\n  private addAudioBase64Chunk = async (chunk: string) => {\n    this.output.gain.gain.value = this.volume;\n    this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    this.output.worklet.port.postMessage({\n      type: \"buffer\",\n      buffer: base64ToArrayBuffer(chunk),\n    });\n  };\n\n  private fadeOutAudio = async () => {\n    // mute agent\n    this.updateMode(\"listening\");\n    this.output.worklet.port.postMessage({ type: \"interrupt\" });\n    this.output.gain.gain.exponentialRampToValueAtTime(\n      0.0001,\n      this.output.context.currentTime + 2\n    );\n\n    // reset volume back\n    setTimeout(() => {\n      this.output.gain.gain.value = this.volume;\n      this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    }, 2000); // Adjust the duration as needed\n  };\n\n  private onError = (message: string, context?: any) => {\n    console.error(message, context);\n    this.options.onError(message, context);\n  };\n\n  private calculateVolume = (frequencyData: Uint8Array) => {\n    if (frequencyData.length === 0) {\n      return 0;\n    }\n\n    // TODO: Currently this averages all frequencies, but we should probably\n    // bias towards the frequencies that are more typical for human voice\n    let volume = 0;\n    for (let i = 0; i < frequencyData.length; i++) {\n      volume += frequencyData[i] / 255;\n    }\n    volume /= frequencyData.length;\n\n    return volume < 0 ? 0 : volume > 1 ? 1 : volume;\n  };\n\n  public getId = () => this.connection.conversationId;\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    this.volume = volume;\n  };\n\n  public getInputByteFrequencyData = () => {\n    this.inputFrequencyData ??= new Uint8Array(\n      this.input.analyser.frequencyBinCount\n    );\n    this.input.analyser.getByteFrequencyData(this.inputFrequencyData);\n    return this.inputFrequencyData;\n  };\n\n  public getOutputByteFrequencyData = () => {\n    this.outputFrequencyData ??= new Uint8Array(\n      this.output.analyser.frequencyBinCount\n    );\n    this.output.analyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  };\n\n  public getInputVolume = () => {\n    return this.calculateVolume(this.getInputByteFrequencyData());\n  };\n\n  public getOutputVolume = () => {\n    return this.calculateVolume(this.getOutputByteFrequencyData());\n  };\n}\n", "import { useEffect, useRef, useState } from \"react\";\nimport {\n  Conversation,\n  Mode,\n  SessionConfig,\n  Callbacks,\n  Options,\n  Status,\n  ClientToolsConfig,\n} from \"@11labs/client\";\nexport type { Role, Mode, Status } from \"@11labs/client\";\n\nexport type HookOptions = Partial<\n  SessionConfig & HookCallbacks & ClientToolsConfig\n>;\nexport type HookCallbacks = Pick<\n  Callbacks,\n  | \"onConnect\"\n  | \"onDisconnect\"\n  | \"onError\"\n  | \"onMessage\"\n  | \"onDebug\"\n  | \"onUnhandledClientToolCall\"\n>;\n\nexport function useConversation<T extends HookOptions>(defaultOptions?: T) {\n  const conversationRef = useRef<Conversation | null>(null);\n  const lockRef = useRef<Promise<Conversation> | null>(null);\n  const [status, setStatus] = useState<Status>(\"disconnected\");\n  const [mode, setMode] = useState<Mode>(\"listening\");\n\n  useEffect(() => {\n    return () => {\n      conversationRef.current?.endSession();\n    };\n  }, []);\n\n  return {\n    startSession: (async (options?: HookOptions) => {\n      if (conversationRef.current) {\n        return conversationRef.current.getId();\n      }\n\n      if (lockRef.current) {\n        const conversation = await lockRef.current;\n        return conversation.getId();\n      }\n\n      try {\n        lockRef.current = Conversation.startSession({\n          ...(defaultOptions ?? {}),\n          ...(options ?? {}),\n          onModeChange: ({ mode }) => {\n            setMode(mode);\n          },\n          onStatusChange: ({ status }) => {\n            setStatus(status);\n          },\n        } as Options);\n\n        conversationRef.current = await lockRef.current;\n        return conversationRef.current.getId();\n      } finally {\n        lockRef.current = null;\n      }\n    }) as T extends SessionConfig\n      ? (options?: HookOptions) => Promise<string>\n      : (options: SessionConfig & HookOptions) => Promise<string>,\n    endSession: async () => {\n      const conversation = conversationRef.current;\n      conversationRef.current = null;\n      await conversation?.endSession();\n    },\n    setVolume: ({ volume }: { volume: number }) => {\n      conversationRef.current?.setVolume({ volume });\n    },\n    getInputByteFrequencyData: () => {\n      return conversationRef.current?.getInputByteFrequencyData();\n    },\n    getOutputByteFrequencyData: () => {\n      return conversationRef.current?.getOutputByteFrequencyData();\n    },\n    getInputVolume: () => {\n      return conversationRef.current?.getInputVolume() ?? 0;\n    },\n    getOutputVolume: () => {\n      return conversationRef.current?.getOutputVolume() ?? 0;\n    },\n    status,\n    isSpeaking: mode === \"speaking\",\n  };\n}\n"],
  "mappings": "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",
  "names": ["arrayBufferToBase64", "b", "buffer", "Uint8Array", "window", "btoa", "String", "fromCharCode", "base64ToArrayBuffer", "base64", "binaryString", "atob", "len", "length", "bytes", "i", "charCodeAt", "blob", "Blob", "type", "rawAudioProcessor", "URL", "createObjectURL", "Input", "sampleRate", "context", "inputStream", "supportsSampleRateConstraint", "navigator", "mediaDevices", "getSupportedConstraints", "AudioContext", "analyser", "createAnalyser", "audioWorklet", "addModule", "getUserMedia", "audio", "ideal", "echoCancellation", "noiseSuppression", "source", "createMediaStreamSource", "worklet", "AudioWorkletNode", "connect", "error", "_inputStream", "_context", "getTracks", "forEach", "track", "stop", "close", "constructor", "this", "audioConcatProcessor", "Output", "gain", "createGain", "destination", "isValidSocketEvent", "event", "Connection", "config", "socket", "_config$origin", "origin", "url", "signedUrl", "agentId", "protocols", "authorization", "push", "WebSocket", "conversationConfig", "Promise", "resolve", "reject", "addEventListener", "_socket", "overridesEvent", "_config$overrides$age", "_config$overrides$age2", "_config$overrides$age3", "_config$overrides$tts", "overrides", "conversation_config_override", "agent", "prompt", "first_message", "firstMessage", "language", "tts", "voice_id", "voiceId", "customLlmExtraBody", "custom_llm_extra_body", "send", "JSON", "stringify", "once", "message", "parse", "data", "conversation_initiation_metadata_event", "console", "warn", "conversationId", "conversation_id", "parseInt", "agent_output_audio_format", "replace", "_socket2", "sendMessage", "defaultClientTools", "clientTools", "defaultCallbacks", "onConnect", "onDebug", "onDisconnect", "onError", "onMessage", "onModeChange", "onStatusChange", "Conversation", "options", "fullOptions", "_extends", "status", "input", "connection", "output", "create", "_connection", "_input", "_output", "_this", "lastInterruptTimestamp", "mode", "inputFrequencyData", "outputFrequencyData", "volume", "endSession", "async", "updateStatus", "updateMode", "onEvent", "parsedEvent", "interruption_event", "event_id", "fadeOutAudio", "agent_response_event", "agent_response", "user_transcription_event", "user_transcript", "response", "tentative_agent_response_internal_event", "tentative_agent_response", "hasOwnProperty", "client_tool_call", "tool_name", "_await$_this$options$", "result", "parameters", "tool_call_id", "is_error", "e", "clientToolName", "onUnhandledClientToolCall", "audio_event", "addAudioBase64Chunk", "audio_base_64", "ping_event", "_unused", "onInputWorkletMessage", "user_audio_chunk", "onOutputWorkletMessage", "finished", "chunk", "value", "port", "postMessage", "exponentialRampToValueAtTime", "currentTime", "setTimeout", "calculateVolume", "frequencyData", "getId", "setVolume", "getInputByteFrequencyData", "frequencyBinCount", "getByteFrequencyData", "getOutputByteFrequencyData", "_this$outputFrequency", "getInputVolume", "getOutputVolume", "onmessage", "useConversation", "defaultOptions", "conversationRef", "useRef", "lockRef", "status", "setStatus", "useState", "mode", "setMode", "useEffect", "_conversationRef$curr", "current", "endSession", "startSession", "async", "getId", "Conversation", "_extends", "options", "onModeChange", "onStatusChange", "conversation", "setVolume", "volume", "_conversationRef$curr2", "getInputByteFrequencyData", "_conversationRef$curr3", "getOutputByteFrequencyData", "_conversationRef$curr4", "getInputVolume", "_conversationRef$curr5", "_conversationRef$curr6", "getOutputVolume", "_conversationRef$curr7", "_conversationRef$curr8", "isSpeaking"]
}
